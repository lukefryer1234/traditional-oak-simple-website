'use server';

import { z } from 'zod';
import { collection, addDoc, getDocs, updateDoc, deleteDoc, doc, orderBy, query, writeBatch } from 'firebase/firestore';
import { db } from '@/lib/firebase';
// TODO: Add Firebase Storage for image uploads if direct upload to server action is implemented

const GALLERY_COLLECTION = 'galleryItems';

export interface GalleryItem {
  id: string;
  order: number;
  imageUrl: string;
  altText: string;
  caption?: string;
  dataAiHint: string;
}

const galleryItemSchema = z.object({
  // id is generated by Firestore or handled separately
  order: z.number().int().min(0),
  imageUrl: z.string().url("Image URL must be a valid URL."),
  altText: z.string().min(1, "Alt text is required.").max(150, "Alt text is too long."),
  caption: z.string().max(250, "Caption is too long.").optional(),
  dataAiHint: z.string().min(1, "AI Hint is required for placeholder generation.").max(50),
});

// For creating, 'id' is not needed
const createGalleryItemSchema = galleryItemSchema;
// For updating, 'id' is crucial
const updateGalleryItemSchema = galleryItemSchema.extend({ id: z.string() });


export async function fetchGalleryItemsAction(): Promise<GalleryItem[]> {
  try {
    const q = query(collection(db, GALLERY_COLLECTION), orderBy("order", "asc"));
    const querySnapshot = await getDocs(q);
    const items: GalleryItem[] = [];
    querySnapshot.forEach((doc) => {
      // Validate data against schema before returning
      const data = doc.data();
      const parsed = galleryItemSchema.safeParse(data); // Assuming 'order' is part of the doc data
      if (parsed.success) {
        items.push({ id: doc.id, ...parsed.data });
      } else {
         console.warn(`Gallery item ${doc.id} failed validation:`, parsed.error.flatten().fieldErrors);
      }
    });
    return items;
  } catch (error) {
    console.error("Error fetching gallery items:", error);
    return [];
  }
}

export interface GalleryItemMutationState {
  message: string;
  success: boolean;
  item?: GalleryItem | GalleryItem[]; // Return single item or updated list
  errors?: z.ZodIssue[];
}

// Action to add a new gallery item
export async function addGalleryItemAction(
  itemData: Omit<GalleryItem, 'id'>
): Promise<GalleryItemMutationState> {
  const validatedFields = createGalleryItemSchema.safeParse(itemData);
  if (!validatedFields.success) {
    return { message: "Validation failed.", success: false, errors: validatedFields.error.errors };
  }

  // TODO: If imageUrl is a File object, handle upload to Firebase Storage first, then use the URL.
  // For now, assuming imageUrl is already a public URL.

  try {
    const docRef = await addDoc(collection(db, GALLERY_COLLECTION), validatedFields.data);
    return {
      message: "Gallery item added successfully.",
      success: true,
      item: { id: docRef.id, ...validatedFields.data }
    };
  } catch (error) {
    console.error("Error adding gallery item:", error);
    return { message: "Failed to add gallery item.", success: false };
  }
}

// Action to update an existing gallery item
export async function updateGalleryItemAction(
  itemData: GalleryItem 
): Promise<GalleryItemMutationState> {
  const validatedFields = updateGalleryItemSchema.safeParse(itemData);
  if (!validatedFields.success) {
    return { message: "Validation failed for update.", success: false, errors: validatedFields.error.errors };
  }

  const { id, ...dataToUpdate } = validatedFields.data;
  // TODO: Handle image URL update (if it's a new file upload)

  try {
    const docRef = doc(db, GALLERY_COLLECTION, id);
    await updateDoc(docRef, dataToUpdate);
    return {
      message: "Gallery item updated successfully.",
      success: true,
      item: { id, ...dataToUpdate }
    };
  } catch (error) {
    console.error("Error updating gallery item:", error);
    return { message: "Failed to update gallery item.", success: false };
  }
}

// Action to delete a gallery item
export async function deleteGalleryItemAction(id: string): Promise<GalleryItemMutationState> {
  if (!id) {
    return { message: "Item ID is required for deletion.", success: false };
  }
  // TODO: If image was uploaded to Firebase Storage, delete it from there as well.

  try {
    await deleteDoc(doc(db, GALLERY_COLLECTION, id));
    return { message: "Gallery item deleted successfully.", success: true };
  } catch (error) {
    console.error("Error deleting gallery item:", error);
    return { message: "Failed to delete gallery item.", success: false };
  }
}


// Action to update the order of all gallery items
export async function updateGalleryOrderAction(
  orderedItems: Pick<GalleryItem, 'id' | 'order'>[]
): Promise<GalleryItemMutationState> {
  if (!Array.isArray(orderedItems)) {
      return { message: "Invalid data format for reordering.", success: false };
  }

  const batch = writeBatch(db);
  try {
      orderedItems.forEach(item => {
          if (item.id && typeof item.order === 'number') {
              const docRef = doc(db, GALLERY_COLLECTION, item.id);
              batch.update(docRef, { order: item.order });
          } else {
              throw new Error("Invalid item structure in orderedItems array.");
          }
      });
      await batch.commit();
      // Optionally refetch and return the new list if needed, or just confirm success
      const updatedItems = await fetchGalleryItemsAction(); 
      return { message: "Gallery order updated successfully.", success: true, item: updatedItems };
  } catch (error: any) {
      console.error("Error updating gallery order:", error);
      return { message: error.message || "Failed to update gallery order.", success: false };
  }
}